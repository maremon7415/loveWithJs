<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Heart Animation | NODi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link
        href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Montserrat:wght@900&display=swap"
        rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            /* Deep black for better contrast */
            font-family: 'Montserrat', sans-serif;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }

        svg {
            display: none;
        }

        /* Main Text Styling */
        .text-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            /* Start hidden */
            z-index: 100;
            pointer-events: none;
            text-align: center;
            opacity: 0;
            /* Start invisible */
        }

        .text-overlay h1 {
            margin: 0;
            font-size: 140px;
            font-weight: 900;
            font-family: 'Dancing Script', cursive;
            color: #fff;
            /* White text for maximum clarity */
            letter-spacing: 5px;
            /* Strong red glow to blend with heart but keep text distinct */
            text-shadow:
                0 0 10px #ff1744,
                0 0 20px #ff1744,
                0 0 40px #d50000,
                0 0 80px #d50000;
            -webkit-text-stroke: 2px rgba(255, 255, 255, 0.8);
            /* White stroke for visibility */
        }

        /* Subtle background floating hearts */
        .hearts-background {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 1;
        }

        .floating-heart {
            position: absolute;
            font-size: 20px;
            color: #ff1744;
            opacity: 0;
            animation: floatUp 15s linear infinite;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(110vh) scale(0.5);
                opacity: 0;
            }

            20% {
                opacity: 0.3;
            }

            80% {
                opacity: 0.3;
            }

            100% {
                transform: translateY(-10vh) scale(1.2);
                opacity: 0;
            }
        }
    </style>
</head>

<body>

    <div class="hearts-background" id="heartsContainer"></div>

    <div class="text-overlay" id="nameContainer">
        <h1 id="nameText">NODi</h1>
    </div>

    <svg viewBox="0 0 600 552">
        <path id="heartPath"
            d="M300,107.77C284.68,55.67,239.76,0,162.31,0,64.83,0,0,82.08,0,171.71c0,.48,0,.95,0,1.43-.52,19.5,0,217.94,299.87,379.69v0l0,0,.05,0,0,0,0,0v0C600,391.08,600.48,192.64,600,173.14c0-.48,0-.95,0-1.43C600,82.08,535.17,0,437.69,0,360.24,0,315.32,55.67,300,107.77" />
    </svg>

    <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js'></script>

    <script>
        /* --- 1. SETUP BACKGROUND EFFECTS --- */
        const heartsContainer = document.getElementById('heartsContainer');
        function createFloatingHeart() {
            const heart = document.createElement('div');
            heart.className = 'floating-heart';
            heart.innerHTML = 'â¤';
            heart.style.left = Math.random() * 100 + '%';
            heart.style.fontSize = (Math.random() * 20 + 10) + 'px';
            heart.style.animationDuration = (Math.random() * 10 + 10) + 's';
            heartsContainer.appendChild(heart);
            setTimeout(() => heart.remove(), 25000);
        }
        setInterval(createFloatingHeart, 800);

        /* --- 2. THREE.JS SCENE SETUP --- */
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.z = 600;

        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        /* --- 3. CREATE HEART PARTICLES --- */
        const path = document.getElementById("heartPath");
        const pathLength = path.getTotalLength();
        const particleCount = 2000; // Increased density for better heart shape
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        // Store original "Heart Shape" positions to animate TO
        const targetPositions = [];

        const color1 = new THREE.Color(0xff0040); // Bright Red
        const color2 = new THREE.Color(0xff4081); // Pink

        for (let i = 0; i < particleCount; i++) {
            // Calculate point on heart path
            const point = path.getPointAtLength((i / particleCount) * pathLength);

            // Center the heart (original SVG is 600x552)
            const x = point.x - 300;
            const y = -(point.y - 276); // Invert Y for 3D space
            const z = (Math.random() - 0.5) * 50; // Slight depth

            // Add some random scatter for the "Target" so it's not a perfect line
            const scatter = 10;
            targetPositions.push({
                x: x + (Math.random() - 0.5) * scatter,
                y: y + (Math.random() - 0.5) * scatter,
                z: z
            });

            // Initial positions (Exploded view)
            positions[i * 3] = (Math.random() - 0.5) * 2000; // Random X
            positions[i * 3 + 1] = (Math.random() - 0.5) * 2000; // Random Y
            positions[i * 3 + 2] = (Math.random() - 0.5) * 2000; // Random Z

            // Color gradient
            const mixedColor = color1.clone().lerp(color2, Math.random());
            colors[i * 3] = mixedColor.r;
            colors[i * 3 + 1] = mixedColor.g;
            colors[i * 3 + 2] = mixedColor.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 4,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.9,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        /* --- 4. ANIMATION LOGIC (GSAP) --- */

        // Helper object to tween arrays
        const particleSystem = {
            progress: 0
        };

        // Main Timeline
        const masterTl = gsap.timeline({ repeat: -1, repeatDelay: 1 });

        // Step A: Form the Heart (Duration: 3.5s)
        masterTl.to(particleSystem, {
            progress: 1,
            duration: 3.5,
            ease: "power3.out",
            onUpdate: () => {
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    // Lerp current position towards target
                    const tx = targetPositions[i].x;
                    const ty = targetPositions[i].y;
                    const tz = targetPositions[i].z;

                    // Interpolate from scattered (stored in current buffer) to target
                    // Note: For a true "from random", we rely on the math below. 
                    // Since we want to re-use this, we calculate based on progress.

                    // Simple trick: We actually updated the buffer in "Step C" to scatter.
                    // So here we pull them back.

                    // To keep it simple and robust, let's just use the logic:
                    // Current = Current + (Target - Current) * factor
                    // But GSAP is cleaner if we access the buffer directly.
                }
            }
        });

        // RE-DOING ANIMATION LOGIC FOR CLEANER LOOP:
        // We will animate the 'dummy' objects representing each particle

        // Create an array of dummy objects for GSAP to manipulate
        const dummies = [];
        for (let i = 0; i < particleCount; i++) {
            dummies.push({
                x: (Math.random() - 0.5) * 3000,
                y: (Math.random() - 0.5) * 3000,
                z: (Math.random() - 0.5) * 3000
            });
        }

        // Function to update geometry from dummies
        function updateParticles() {
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = dummies[i].x;
                positions[i * 3 + 1] = dummies[i].y;
                positions[i * 3 + 2] = dummies[i].z;
            }
            particles.geometry.attributes.position.needsUpdate = true;
        }

        // --- RESTART TIMELINE ---
        masterTl.clear();

        // 1. CONVERGE: Particles fly from random -> Heart Shape
        masterTl.to(dummies, {
            x: (i) => targetPositions[i].x,
            y: (i) => targetPositions[i].y,
            z: (i) => targetPositions[i].z,
            duration: 3,
            ease: "elastic.out(1, 0.5)",
            stagger: { amount: 0.5, from: "random" },
            onUpdate: updateParticles
        });

        // 2. REVEAL TEXT: Text appears AFTER heart is formed
        masterTl.to("#nameContainer", {
            opacity: 1,
            scale: 1,
            duration: 1.5,
            ease: "back.out(1.7)"
        }, "-=0.5"); // Start slightly before particles finish settling

        // 3. THE "HOLD" (Heartbeat & Wait) - 10 Seconds
        // We use a loop for the heartbeat effect during the wait
        for (let i = 0; i < 8; i++) { // 8 beats roughly covers 10 seconds
            masterTl.to(particles.scale, { x: 1.1, y: 1.1, duration: 0.2, ease: "power1.out" });
            masterTl.to(particles.scale, { x: 1, y: 1, duration: 0.4, ease: "power1.in" });
            masterTl.to({}, { duration: 0.6 }); // Pause between beats
        }

        // 4. EXIT: Text Hides & Heart Explodes TOGETHER
        masterTl.to("#nameContainer", {
            opacity: 0,
            scale: 3,
            filter: "blur(20px)",
            duration: 1.5,
            ease: "power2.in"
        }, "exit");

        masterTl.to(dummies, {
            x: () => (Math.random() - 0.5) * 3000,
            y: () => (Math.random() - 0.5) * 3000,
            z: () => (Math.random() - 0.5) * 2000,
            duration: 2,
            ease: "power3.in",
            onUpdate: updateParticles
        }, "exit"); // Run at label "exit" syncs with text hiding


        /* --- 5. RENDER LOOP --- */
        function animate() {
            requestAnimationFrame(animate);

            // Gentle rotation of the whole system
            particles.rotation.y += 0.002;
            particles.rotation.z = Math.sin(Date.now() * 0.001) * 0.05;

            renderer.render(scene, camera);
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>