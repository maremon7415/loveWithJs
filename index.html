<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Heart Animation | NODi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link
        href="https://fonts.googleapis.com/css2?family=Pacifico&family=Great+Vibes&family=Dancing+Script:wght@700&display=swap"
        rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Arial', sans-serif;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        svg {
            position: absolute;
            display: none;
        }

        /* RESPONSIVE TEXT UPDATES */
        .text-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5);

            /* Responsive Font Size: 
         It uses 18% of screen width, but never smaller than 50px 
         and never bigger than 130px */
            font-size: clamp(50px, 18vw, 130px);

            font-weight: 900;
            font-family: 'Dancing Script', cursive;
            color: #ffffff;
            -webkit-text-stroke: 2px #ff1744;
            text-shadow:
                0 0 10px rgba(255, 23, 68, 1),
                0 0 20px rgba(255, 23, 68, 0.8),
                0 0 40px rgba(255, 23, 68, 0.6);
            z-index: 10;
            pointer-events: none;
            letter-spacing: 5px;
            /* Reduced slightly for mobile safety */
            white-space: nowrap;
            /* Prevents text from breaking into two lines */
            opacity: 0;
        }

        .hearts-background {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 1;
        }

        .floating-heart {
            position: absolute;
            font-size: 20px;
            opacity: 0;
            animation: float 8s ease-in-out infinite;
            filter: drop-shadow(0 0 10px rgba(255, 23, 68, 0.8));
            color: #ff1744;
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }

            10% {
                opacity: 0.4;
            }

            90% {
                opacity: 0.4;
            }

            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }

        .sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
            pointer-events: none;
            animation: sparkleAnim 1.5s ease-out forwards;
            box-shadow: 0 0 10px rgba(255, 255, 255, 1);
        }

        @keyframes sparkleAnim {
            0% {
                opacity: 1;
                transform: scale(0);
            }

            50% {
                opacity: 1;
                transform: scale(1.5);
            }

            100% {
                opacity: 0;
                transform: scale(0) translateY(-50px);
            }
        }
    </style>
</head>

<body>

    <div class="hearts-background" id="heartsContainer"></div>
    <div class="text-overlay" id="nameText">NODi</div>

    <svg viewBox="0 0 600 552">
        <path
            d="M300,107.77C284.68,55.67,239.76,0,162.31,0,64.83,0,0,82.08,0,171.71c0,.48,0,.95,0,1.43-.52,19.5,0,217.94,299.87,379.69v0l0,0,.05,0,0,0,0,0v0C600,391.08,600.48,192.64,600,173.14c0-.48,0-.95,0-1.43C600,82.08,535.17,0,437.69,0,360.24,0,315.32,55.67,300,107.77"
            fill="#ee5282" />
    </svg>

    <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js'></script>

    <script>
        console.clear();

        const heartsContainer = document.getElementById('heartsContainer');
        function createFloatingHeart() {
            const heart = document.createElement('div');
            heart.className = 'floating-heart';
            heart.innerHTML = 'â¤';
            heart.style.left = Math.random() * 100 + '%';
            heart.style.animationDelay = Math.random() * 5 + 's';
            heart.style.animationDuration = (Math.random() * 4 + 6) + 's';
            heart.style.fontSize = (Math.random() * 15 + 12) + 'px';
            heartsContainer.appendChild(heart);
            setTimeout(() => { heart.remove(); }, 10000);
        }

        setInterval(createFloatingHeart, 1000);
        for (let i = 0; i < 8; i++) { setTimeout(createFloatingHeart, i * 1000); }

        function createSparkle() {
            const nameElement = document.getElementById('nameText');
            const style = window.getComputedStyle(nameElement);
            if (style.opacity < 0.5) return;

            const rect = nameElement.getBoundingClientRect();
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';

            const angle = Math.random() * Math.PI * 2;
            const distance = 80 + Math.random() * 40;
            // Adjust sparkle positions based on current text size
            const x = rect.left + rect.width / 2 + Math.cos(angle) * (rect.width / 2);
            const y = rect.top + rect.height / 2 + Math.sin(angle) * (rect.height / 2);

            sparkle.style.left = x + 'px';
            sparkle.style.top = y + 'px';
            document.body.appendChild(sparkle);

            setTimeout(() => sparkle.remove(), 1500);
        }
        setInterval(() => { for (let i = 0; i < 3; i++) setTimeout(createSparkle, i * 100); }, 500);


        /* --- THREE.JS SETUP --- */
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);

        // RESPONSIVE CAMERA LOGIC
        function updateCameraPosition() {
            if (window.innerWidth < 600) {
                // Mobile: Move camera back significantly
                camera.position.z = 1100;
            } else if (window.innerWidth < 900) {
                // Tablet
                camera.position.z = 800;
            } else {
                // Desktop
                camera.position.z = 500;
            }
        }
        updateCameraPosition(); // Set on load

        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        document.body.appendChild(renderer.domElement);

        /* --- ANIMATION LOGIC (UNCHANGED) --- */
        const tl = gsap.timeline({ repeat: -1 });

        const path = document.querySelector("path");
        const length = path.getTotalLength();
        const vertices = [];
        const colors = [];

        const color1 = new THREE.Color(0xff1744);
        const color2 = new THREE.Color(0xd81b60);
        const color3 = new THREE.Color(0xff4081);

        for (let i = 0; i < length; i += 0.08) {
            const point = path.getPointAtLength(i);
            const vector = new THREE.Vector3(point.x, -point.y, 0);

            vector.x += (Math.random() - 0.5) * 45;
            vector.y += (Math.random() - 0.5) * 45;
            vector.z += (Math.random() - 0.5) * 120;

            vertices.push(vector);

            const ratio = i / length;
            let color;
            if (ratio < 0.33) color = color1.clone().lerp(color2, ratio * 3);
            else if (ratio < 0.66) color = color2.clone().lerp(color3, (ratio - 0.33) * 3);
            else color = color3.clone().lerp(color1, (ratio - 0.66) * 3);

            colors.push(color.r, color.g, color.b);

            tl.from(vector, {
                x: 600 / 2 + (Math.random() - 0.5) * 150,
                y: -552 / 2 + (Math.random() - 0.5) * 150,
                z: (Math.random() - 0.5) * 300,
                ease: "elastic.out(1, 0.4)",
                duration: "random(3, 7)"
            }, i * 0.0012);
        }

        const geometry = new THREE.BufferGeometry().setFromPoints(vertices);
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 5,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 1
        });

        const particles = new THREE.Points(geometry, material);
        particles.position.x -= 600 / 2;
        particles.position.y += 552 / 2;
        scene.add(particles);

        // Timeline Sequence
        tl.to(".text-overlay", {
            opacity: 1,
            scale: 1,
            duration: 2,
            ease: "power2.out"
        }, "-=1.5");

        // WAIT 10 SECONDS
        tl.to({}, { duration: 10 });

        tl.add("exit");

        tl.to(".text-overlay", {
            opacity: 0,
            scale: 1.5,
            filter: "blur(20px)",
            duration: 1
        }, "exit");

        tl.to(vertices, {
            x: () => (Math.random() - 0.5) * 1500,
            y: () => (Math.random() - 0.5) * 1500,
            z: () => (Math.random() - 0.5) * 1500,
            duration: 3,
            ease: "power2.in",
            stagger: { amount: 1, from: "random" }
        }, "exit");

        tl.to({}, { duration: 1 });


        // --- GLOW PARTICLES ---
        const glowGeometry = new THREE.BufferGeometry();
        const glowVertices = [];
        const glowColors = [];
        for (let i = 0; i < 300; i++) {
            const radius = Math.random() * 90 + 20;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI * 2;
            glowVertices.push(
                radius * Math.sin(theta) * Math.cos(phi),
                radius * Math.sin(theta) * Math.sin(phi),
                radius * Math.cos(theta)
            );
            const glowColor = new THREE.Color(0xff1744);
            glowColors.push(glowColor.r, glowColor.g, glowColor.b);
        }
        glowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(glowVertices, 3));
        glowGeometry.setAttribute('color', new THREE.Float32BufferAttribute(glowColors, 3));
        const glowMaterial = new THREE.PointsMaterial({
            size: 7, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0
        });
        const glowParticles = new THREE.Points(glowGeometry, glowMaterial);
        scene.add(glowParticles);

        gsap.to(glowMaterial, { opacity: 0.6, duration: 2, repeat: -1, yoyo: true, delay: 4 });
        gsap.to(glowParticles.rotation, { z: Math.PI * 2, duration: 12, repeat: -1, ease: 'none' });
        gsap.to(glowParticles.scale, { x: 1.4, y: 1.4, z: 1.4, duration: 2.5, repeat: -1, yoyo: true, ease: 'power2.inOut' });

        gsap.fromTo(scene.rotation,
            { y: -0.35, x: -0.12 },
            { y: 0.35, x: 0.12, repeat: -1, yoyo: true, ease: 'power2.inOut', duration: 5 }
        );

        function render() {
            requestAnimationFrame(render);
            geometry.setFromPoints(vertices);
            glowParticles.rotation.y += 0.003;
            glowParticles.rotation.x += 0.001;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            updateCameraPosition(); // Update Z position on resize
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener("resize", onWindowResize, false);

        requestAnimationFrame(render);
    </script>

</body>

</html>